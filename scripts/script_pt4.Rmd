---
title: "Tidying data (and some things on tibbles)"
author: "Felix Lennert"
date: "knit on `r lubridate::today()`"
output: html_document
csl: ASA.csl
bibliography: bibliographyR.bib
---

# Intro

Before you learn how to tidy and wrangle data, you actually need to now how you want your dataset to actually look like, i.e., what the desired outcome of the entire process of tidying your dataset is. The `tidyverse` is a collection of packages which share an underlying philosophy: they are tidy. This means, that they (preferably) take tidy data as inputs and output tidy data. In the following, I will, first, introduce you to the concept of tidy data as developed by Hadley Wickham [@wickham2014]. Second, `tidyr` is introduced. Its goal is to provide you with functions that facilitate tidying datasets. 

Please note that tidying and cleaning data are not equivalent: I refer to tidying data as to bringing data in a tidy format. Cleaning data, however, can encompass way more than this: parsing columns in the right format (using `readr`, for instance), imputation of missing values, address the problem of typos, etc. 

# The concept of *tidy data*

Datasets can be structured in many ways. To make them tidy, they must be organized in the following way (this is taken from the R for Data Science book [@wickham2016a]):

1. Each variable must have its own column.   
2. Each observation must have its own row.     
3. Each value must have its own cell.

They can even be boiled further down:

1. Put each dataset in a tibble.
2. Put each variable in a column.

This can also be visually depicted:

![The three rules that make a dataset tidy (taken from Wickham and Grolemund 2016: 149)](figures/tidy_data.png)

# Making messy data tidy

So what are the most common problems with datasets? The following list is taken from the `tidyr` vignette^[which can be found [here](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) or using `vignette("tidy-data", package = "tidyr")`]:

* Column headers are values, not variable names.    
* Multiple variables are stored in one colums.
* Variables are stored in both rows and columns.  
* Multiple types of observational units are stored in the same table.  
* A single observational unit is stored in multiple tables.  

In the following, I will provide you with examples on how this might look like and how you can address the respective problem using functions from the `tidyr` package. At the beginning of every part, I will build the tibble using functions from the tibble package. This should suffice as a quick refresher for tibbles.

## Column headers are values

A dataset of this form would look like this:

```{r}
library(tidyverse)

tibble_value_headers <- tibble(
  manufacturer = c("Audi", "BMW", "Mercedes", "Opel", "VW"),
  `3 cyl` = sample(20, 5, replace = TRUE),
  `4 cyl` = sample(50:100, 5, replace = TRUE),
  `5 cyl` = sample(10, 5, replace = TRUE),
  `6 cyl` = sample(30:50, 5, replace = TRUE),
  `8 cyl` = sample(20:40, 5, replace = TRUE),
  `10 cyl` = sample(10, 5, replace = TRUE),
  `12 cyl` = sample(20, 5, replace = TRUE),
  `16 cyl` = rep(0, 5)
)

tibble_value_headers
```

This dataset basically consists of three variables: `German car manufacturer`, `number of cylinders`, and `frequency`. To make the dataset tidy, it has to consist of three columns depicting the three respective variables. This operation is called pivoting the non-variable columns into two-column key-value pairs. As the dataset will thereafter contain fewer columns and more rows than before, it will have become longer (or taller). Hence, the tidyr function is called `pivot_longer()`.

```{r}
ger_car_manufacturer_longer <- tibble_value_headers %>% 
  pivot_longer(-manufacturer, names_to = "cylinders", values_to = "frequency")
ger_car_manufacturer_longer
```

## Multiple variables in one column

Now, however, there is a problem with the cylinders: their number should be depicted in a numeric vector. We could achieve this by either parsing it to a numeric vector:

```{r}
parse_number(ger_car_manufacturer_longer$cylinders)
```

On the other hand, we can also use a handy function from `tidyr` called `separate()` and afterwards drop the unnecessary column:

```{r}
ger_car_manufacturer_longer_sep_cyl <- ger_car_manufacturer_longer %>% 
  separate(cylinders, into = c("cylinders", "drop_it"), sep = " ") %>% 
  select(-drop_it) # you will learn about this in the lesson on dplyr 
```

If there are two (or actually more) relevant values in one column, you can simply let out the dropping process and easily split them into multiple columns.

Please note that the new column is still in character format. We can change this using `as.numeric()`:

```{r}
ger_car_manufacturer_longer_sep_cyl$cylinders <- as.numeric(ger_car_manufacturer_longer_sep_cyl$cylinders)
```

Furthermore, you might want to sort your data in a different manner. If you want to do this by cylinders, it would look like this:

```{r}
arrange(ger_car_manufacturer_longer_sep_cyl, cylinders)
```

# Insertion: the pipe

Have you noticed the ` %>% `? That's the pipe. It's from the `magrittr` package whose name is based on the Belgian painter who has painted this masterpiece:

![figures/pipe1.png]

Just kidding:

![figures/pipe2.png]


It can be considered a conjunction in coding. Usually, you will use it when working with tibbles. What it does is pretty straight-forward: it takes what is on its left -- the input -- and provides it to the function on its right as the first argument. Hence, the code in the last chunk, which looks like this

```{r}
arrange(ger_car_manufacturer_longer_sep_cyl, cylinders)
```

could have also been written like this

```{r}
ger_car_manufacturer_longer_sep_cyl %>% arrange(cylinders)
```

because the tibble is the first argument in the function call.

Because `magrittr` really has gained traction in the R community, many functions are now optimized for being used with the pipe. However, there are still some around which are not. A function for fitting a basic linear model with one dependend and one independent variable which are both stored in a tibble looks like this: `lm(formula = dv ~ iv, data = tibble)`. Here, the tibble is not the first argument. To be able to fit a linear model in a "pipeline," you need to employ a little hack: you can use a dot `.` as a placeholder. 

Let's check out the effect the number of cylinders has on the number of models:

```{r}
ger_car_manufacturer_longer_sep_cyl %>% 
  lm(frequency ~ cylinders, data = .) %>% 
  summary()
```

You can think of the pipe as "and then":

```{r}
ger_car_manufacturer_longer_sep_cyl <- ger_car_manufacturer_longer %>% # first, take the tibble
  separate(cylinders, into = c("cylinders", "drop_it"), sep = " ") %>% # and then split the column "cylinders" into two
  select(-drop_it) # you will learn about this in the lesson on dplyr  # and then drop one column from the tibble
```

As ` %>% ` is a bit tedious to type, there exist shortcuts: shift-ctrl-m on a Mac, shift-strg-m on a Windows machine.

# * Variables are stored in both rows and columns.  
* Multiple types of observational units are stored in the same table.  
* A single observational unit is stored in multiple tables.  